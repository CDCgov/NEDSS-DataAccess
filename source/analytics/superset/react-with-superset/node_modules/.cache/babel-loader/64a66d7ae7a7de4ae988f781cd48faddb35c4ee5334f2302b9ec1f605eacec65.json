{"ast":null,"code":"(function () {\n  var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;\n  enterModule && enterModule(module);\n})();\nvar __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {\n  return a;\n};\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;\n(function (Actions) {\n  Actions[\"GET\"] = \"get\";\n  Actions[\"REPLY\"] = \"reply\";\n  Actions[\"EMIT\"] = \"emit\";\n  Actions[\"ERROR\"] = \"error\";\n})(Actions || (Actions = {}));\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n}\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n  // used to make unique ids\n\n  constructor(params) {\n    this.port = void 0;\n    this.name = '';\n    this.methods = {};\n    this.incrementor = 1;\n    this.debugMode = void 0;\n    this.isInitialised = void 0;\n    if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n  init(params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n    const {\n      port,\n      name = 'switchboard',\n      debug = false\n    } = params;\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n    port.addEventListener('message', async event => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const {\n          method,\n          args\n        } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n    this.isInitialised = true;\n  }\n  async getMethodResult(_ref) {\n    let {\n      messageId,\n      method,\n      args\n    } = _ref;\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined`\n      };\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result\n      };\n    } catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error`\n      };\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args) {\n    if (args === void 0) {\n      args = undefined;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = event => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message) ? message.error : 'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args\n      };\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args) {\n    if (args === void 0) {\n      args = undefined;\n    }\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args\n    };\n    this.port.postMessage(message);\n  }\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n  log() {\n    if (this.debugMode) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n  logError() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    console.error(`[${this.name}]`, ...args);\n  }\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {\n    // @ts-ignore\n    this[key] = eval(code);\n  }\n}\nconst _default = new Switchboard();\nexport default _default;\n;\n(function () {\n  var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;\n  if (!reactHotLoader) {\n    return;\n  }\n  reactHotLoader.register(isGet, \"isGet\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isReply, \"isReply\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isEmit, \"isEmit\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(isError, \"isError\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n  reactHotLoader.register(_default, \"default\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");\n})();\n;\n(function () {\n  var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;\n  leaveModule && leaveModule(module);\n})();","map":{"version":3,"names":["enterModule","reactHotLoaderGlobal","undefined","module","__signature__","default","signature","a","Actions","isGet","message","switchboardAction","GET","isReply","REPLY","isEmit","EMIT","isError","ERROR","Switchboard","constructor","params","port","name","methods","incrementor","debugMode","isInitialised","init","logError","debug","addEventListener","event","log","data","postMessage","getMethodResult","method","args","executor","_ref","messageId","error","result","err","defineMethod","methodName","get","Promise","resolve","reject","Error","getNewMessageId","listener","removeEventListener","errStr","start","emit","_len","arguments","length","Array","_key","console","_len2","_key2","__reactstandin__regenerateByEval","key","code","eval","_default","reactHotLoader","register","leaveModule"],"sources":["/Users/UpasanaPattnaik/react-with-superset/node_modules/@superset-ui/switchboard/esm/switchboard.js"],"sourcesContent":["(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Each message we send on the channel specifies an action we want the other side to cooperate with.\nvar Actions;(function (Actions) {Actions[\"GET\"] = \"get\";Actions[\"REPLY\"] = \"reply\";Actions[\"EMIT\"] = \"emit\";Actions[\"ERROR\"] = \"error\";})(Actions || (Actions = {}));\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction isGet(message) {\n  return message.switchboardAction === Actions.GET;\n}\n\n\n\n\n\n\n\nfunction isReply(message) {\n  return message.switchboardAction === Actions.REPLY;\n}\n\n\n\n\n\n\n\nfunction isEmit(message) {\n  return message.switchboardAction === Actions.EMIT;\n}\n\n\n\n\n\n\n\nfunction isError(message) {\n  return message.switchboardAction === Actions.ERROR;\n}\n\n/**\n * A utility for communications between an iframe and its parent, used by the Superset embedded SDK.\n * This builds useful patterns on top of the basic functionality offered by MessageChannel.\n *\n * Both windows instantiate a Switchboard, passing in their MessagePorts.\n * Calling methods on the switchboard causes messages to be sent through the channel.\n */\nexport class Switchboard {\n\n\n\n\n\n\n  // used to make unique ids\n\n\n\n\n\n\n  constructor(params) {this.port = void 0;this.name = '';this.methods = {};this.incrementor = 1;this.debugMode = void 0;this.isInitialised = void 0;\n    if (!params) {\n      return;\n    }\n    this.init(params);\n  }\n\n  init(params) {\n    if (this.isInitialised) {\n      this.logError('already initialized');\n      return;\n    }\n\n    const { port, name = 'switchboard', debug = false } = params;\n\n    this.port = port;\n    this.name = name;\n    this.debugMode = debug;\n\n    port.addEventListener('message', async (event) => {\n      this.log('message received', event);\n      const message = event.data;\n      if (isGet(message)) {\n        // find the method, call it, and reply with the result\n        this.port.postMessage(await this.getMethodResult(message));\n      } else if (isEmit(message)) {\n        const { method, args } = message;\n        // Find the method and call it, but no result necessary.\n        // Should this multicast to a set of listeners?\n        // Maybe, but that requires writing a bunch more code\n        // and I haven't found a need for it yet.\n        const executor = this.methods[method];\n        if (executor) {\n          executor(args);\n        }\n      }\n    });\n\n    this.isInitialised = true;\n  }\n\n  async getMethodResult(_ref)\n\n\n\n  {let { messageId, method, args } = _ref;\n    const executor = this.methods[method];\n    if (executor == null) {\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" is not defined` };\n\n    }\n    try {\n      const result = await executor(args);\n      return {\n        switchboardAction: Actions.REPLY,\n        messageId,\n        result };\n\n    } catch (err) {\n      this.logError(err);\n      return {\n        switchboardAction: Actions.ERROR,\n        messageId,\n        error: `[${this.name}] Method \"${method}\" threw an error` };\n\n    }\n  }\n\n  /**\n   * Defines a method that can be \"called\" from the other side by sending an event.\n   */\n  defineMethod(methodName, executor) {\n    this.methods[methodName] = executor;\n  }\n\n  /**\n   * Calls a method registered on the other side, and returns the result.\n   *\n   * How this is accomplished:\n   * This switchboard sends a \"get\" message over the channel describing which method to call with which arguments.\n   * The other side's switchboard finds a method with that name, and calls it with the arguments.\n   * It then packages up the returned value into a \"reply\" message, sending it back to us across the channel.\n   * This switchboard has attached a listener on the channel, which will resolve with the result when a reply is detected.\n   *\n   * Instead of an arguments list, arguments are supplied as a map.\n   *\n   * @param method the name of the method to call\n   * @param args arguments that will be supplied. Must be serializable, no functions or other nonense.\n   * @returns whatever is returned from the method\n   */\n  get(method, args) {if (args === void 0) {args = undefined;}\n    return new Promise((resolve, reject) => {\n      if (!this.isInitialised) {\n        reject(new Error('Switchboard not initialised'));\n        return;\n      }\n      // In order to \"call a method\" on the other side of the port,\n      // we will send a message with a unique id\n      const messageId = this.getNewMessageId();\n      // attach a new listener to our port, and remove it when we get a response\n      const listener = (event) => {\n        const message = event.data;\n        if (message.messageId !== messageId) return;\n        this.port.removeEventListener('message', listener);\n        if (isReply(message)) {\n          resolve(message.result);\n        } else {\n          const errStr = isError(message) ?\n          message.error :\n          'Unexpected response message';\n          reject(new Error(errStr));\n        }\n      };\n      this.port.addEventListener('message', listener);\n      this.port.start();\n      const message = {\n        switchboardAction: Actions.GET,\n        method,\n        messageId,\n        args };\n\n      this.port.postMessage(message);\n    });\n  }\n\n  /**\n   * Emit calls a method on the other side just like get does.\n   * But emit doesn't wait for a response, it just sends and forgets.\n   *\n   * @param method\n   * @param args\n   */\n  emit(method, args) {if (args === void 0) {args = undefined;}\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    const message = {\n      switchboardAction: Actions.EMIT,\n      method,\n      args };\n\n    this.port.postMessage(message);\n  }\n\n  start() {\n    if (!this.isInitialised) {\n      this.logError('Switchboard not initialised');\n      return;\n    }\n    this.port.start();\n  }\n\n  log() {\n    if (this.debugMode) {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      console.debug(`[${this.name}]`, ...args);\n    }\n  }\n\n  logError() {for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {args[_key2] = arguments[_key2];}\n    console.error(`[${this.name}]`, ...args);\n  }\n\n  getNewMessageId() {\n    // eslint-disable-next-line no-plusplus\n    return `m_${this.name}_${this.incrementor++}`;\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}}const _default =\nnew Switchboard();export default _default;;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(isGet, \"isGet\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isReply, \"isReply\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isEmit, \"isEmit\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(isError, \"isError\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(Switchboard, \"Switchboard\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");reactHotLoader.register(_default, \"default\", \"/Users/ville/apple/apache-superset/superset-frontend/packages/superset-ui-switchboard/src/switchboard.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}